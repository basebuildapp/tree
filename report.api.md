## API Report File for "@atlaskit/tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Component } from 'react';
import { DraggableId } from 'react-beautiful-dnd-next';
import { DraggableLocation } from 'react-beautiful-dnd-next';
import { DraggableProvided } from 'react-beautiful-dnd-next';
import { DraggableProvidedDraggableProps } from 'react-beautiful-dnd-next';
import { DraggableProvidedDragHandleProps } from 'react-beautiful-dnd-next';
import { DraggableStateSnapshot } from 'react-beautiful-dnd-next';
import { DragStart } from 'react-beautiful-dnd-next';
import { DragUpdate } from 'react-beautiful-dnd-next';
import { DroppableId } from 'react-beautiful-dnd-next';
import { DroppableProvided } from 'react-beautiful-dnd-next';
import { DropResult } from 'react-beautiful-dnd-next';
import { ReactNode } from 'react';

declare type Combine = {
  draggableId: DraggableId;
  droppableId: DroppableId;
};

declare class DelayedFunction {
  delay: number;
  timeoutId: number | undefined;
  fn?: Function;
  constructor(delay: number);
  start(fn: Function): void;
  stop(): void;
}

declare type DragState = {
  source: DraggableLocation;
  mode: string;
  destination?: DraggableLocation;
  horizontalLevel?: number;
  combine?: Combine;
};

declare type FlattenedItem = {
  item: TreeItem;
  path: Path;
};

declare type FlattenedTree = FlattenedItem[];

export declare type ItemId = string | number;

export declare const moveItemOnTree: (
  tree: TreeData,
  from: TreeSourcePosition,
  to: TreeDestinationPosition,
) => TreeData;

export declare const mutateTree: (
  tree: TreeData,
  itemId: ItemId,
  mutation: TreeItemMutation,
) => TreeData;

export declare type Path = number[];

declare type Props = {
  /** The tree data structure. */
  tree: TreeData;
  /** Function that will be called when a parent item needs to be expanded. */
  onExpand: (itemId: ItemId, path: Path) => void;
  /** Function that will be called when a parent item needs to be collapsed. */
  onCollapse: (itemId: ItemId, path: Path) => void;
  /** Function that will be called when the user starts dragging. */
  onDragStart: (itemId: ItemId) => void;
  /** Function that will be called when the user finishes dragging. */
  onDragEnd: (
    sourcePosition: TreeSourcePosition,
    destinationPosition?: TreeDestinationPosition,
  ) => void;
  /** Function that will be called to render a single item. */
  renderItem: (item: RenderItemParams) => ReactNode;
  /** Number of pixel is used to scaffold the tree by the consumer. */
  offsetPerLevel: number;
  /** Boolean to turn on drag&drop re-ordering on the tree */
  isDragEnabled: boolean | ((item: TreeItem) => boolean);
  /** Boolean to turn on hovering while dragging */
  isNestingEnabled: boolean;
};

export declare type RenderItemParams = {
  item: TreeItem;
  depth: number;
  onExpand: (itemId: ItemId) => void;
  onCollapse: (itemId: ItemId) => void;
  provided: TreeDraggableProvided;
  snapshot: DraggableStateSnapshot;
};

declare type State = {
  /** The flattened tree data structure transformed from props.tree */
  flattenedTree: FlattenedTree;
  draggedItemId?: ItemId;
};

declare class Tree extends Component<Props, State> {
  static defaultProps: {
    tree: {
      children: never[];
    };
    onExpand: () => void;
    onCollapse: () => void;
    onDragStart: () => void;
    onDragEnd: () => void;
    renderItem: () => void;
    offsetPerLevel: number;
    isDragEnabled: boolean;
    isNestingEnabled: boolean;
  };
  state: {
    flattenedTree: never[];
    draggedItemId: undefined;
  };
  dragState?: DragState;
  itemsElement: Record<ItemId, HTMLElement | undefined>;
  containerElement: HTMLElement | undefined;
  expandTimer: DelayedFunction;
  static getDerivedStateFromProps(
    props: Props,
    state: State,
  ): {
    flattenedTree: FlattenedItem[];
    draggedItemId?: ItemId | undefined;
  };
  static closeParentIfNeeded(tree: TreeData, draggedItemId?: ItemId): TreeData;
  onDragStart: (result: DragStart) => void;
  onDragUpdate: (update: DragUpdate) => void;
  onDropAnimating: () => void;
  onDragEnd: (result: DropResult) => void;
  onPointerMove: () => void;
  calculateEffectivePath: (
    flatItem: FlattenedItem,
    snapshot: DraggableStateSnapshot,
  ) => Path;
  isExpandable: (item: FlattenedItem) => boolean;
  getDroppedLevel: () => number | undefined;
  patchDroppableProvided: (provided: DroppableProvided) => DroppableProvided;
  setItemRef: (itemId: ItemId, el: HTMLElement | null) => void;
  renderItems: () => Array<ReactNode>;
  renderItem: (flatItem: FlattenedItem, index: number) => ReactNode;
  renderDraggableItem: (
    flatItem: FlattenedItem,
  ) => (
    provided: DraggableProvided,
    snapshot: DraggableStateSnapshot,
  ) => JSX.Element;
  renderTreeItem: ({
    flatItem,
    path,
    provided,
    snapshot,
  }: {
    flatItem: FlattenedItem;
    path: Path;
    provided: DraggableProvided;
    snapshot: DraggableStateSnapshot;
  }) => JSX.Element;
  render(): JSX.Element;
}
export default Tree;

export declare interface TreeData {
  rootId: ItemId;
  items: Record<ItemId, TreeItem>;
}

export declare type TreeDestinationPosition = {
  parentId: ItemId;
  index?: number;
};

declare type TreeDraggableProvided = {
  draggableProps: DraggableProvidedDraggableProps;
  dragHandleProps: DraggableProvidedDragHandleProps | null;
  innerRef: (el: HTMLElement | null) => void;
};

export declare type TreeItem = {
  id: ItemId;
  children: ItemId[];
  hasChildren?: boolean;
  isExpanded?: boolean;
  isChildrenLoading?: boolean;
  data?: TreeItemData;
};

declare type TreeItemData = any;

declare type TreeItemMutation = {
  id?: ItemId;
  children?: ItemId[];
  hasChildren?: boolean;
  isExpanded?: boolean;
  isChildrenLoading?: boolean;
  data?: TreeItemData;
};

export declare type TreeSourcePosition = {
  parentId: ItemId;
  index: number;
};

export {};
```
