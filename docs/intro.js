"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var react_1 = require("react");
var docs_1 = require("@atlaskit/docs");
exports["default"] = docs_1.md(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n  Tree component provides a generic way to visualize tree structures. It was built on top of the popular [react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd)\n  library in order to provide a natural way of reorganizing the nodes.\n\n  ## Feature set\n\n   - Fully customizable node rendering\n   - Capability to collapse and expand subtree\n   - Lazy loading of subtree\n   - Reorganization of the tree by drag&drop\n   - Mouse, touch and keyboard support\n\n  ## Usage\n\n  ", "\n\n  ", "\n\n  ## Get started\n\n  ### Tree data structure\n\n  Tree is defined by a normalized data structure, where _rootId_ defines the _id_ of the root node and _items_ map contains all the nodes indexed by their _id_.\n  Child relationship is defined in the _children_ field of parent in form of list of _id_'s.\n\n  **Data attribute:** Any consumer data should be defined in the _data_ attribute of item, e.g. title, color, selection etc.\n\n  **State handling:** This data structure is the single source of truth. After any interaction the consumer's responsibility to execute the mutation\n   on the tree, which will be passed down in props to refresh the rendered tree. A few utils functions (_mutateTree_, _moveItemOnTree_) are provided\n   in order to help you make those changes easily and in a efficient way.\n\n  **Performance / Side-effects:** We put some effort into optimizing rendering based on reference equality. We only re-render an Item if it's reference changed or\n  moved on the tree.\n\n  ", "\n\n  ### Rendering\n\n  In order to render the tree, _renderItem_ render prop must be defined on _Tree_. It will receive one object with multiple params, defined as _RenderItemParams_ .\n\n  **Root item** is not rendered by design. If you want to render a tree with a single root, you will need to create a virtual root above your effective root.\n\n  **Provided** is a concept inherited from react-beautiful-dnd library in order to provide flexible drag&drop functionality.\n\n   - _innerRef_ must be bound to the highest possible DOM node in the ReactElement. We do this in order to avoid needing to use ReactDOM to look up your DOM node.\n   - _draggableProps_ is an Object that contains a data attribute and an inline style. This Object needs to be applied to the same node that you apply provided.innerRef to. This controls the movement of the draggable when it is dragging and not dragging.\n   - _dragHandleProps_ is used to drag the whole tree item. Often this will be the highest level node, but sometimes it can be a child node. dragHandleProps need to be applied to the node that you want to be the drag handle.\n\n  ", "\n\n  **Example**\n\n  ", "\n\n  ### Expand & Collapse\n\n  _onExpand_ and _onCollapse_ functions are triggered when there is a need to change the state of a parent. This is the right time to trigger requests to load the subtree or\n  flip the _isExpanded_ attribute to show the already loaded children nodes.\n\n  **Example**\n\n  ", "\n\n  ### Drag & Drop\n\n  Drag&Drop is powered by [react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd), so a couple of design principles are inherited from there. To make it work\n  _provided_ from _renderItem_ must be used as defined earlier in the Rendering section. For custom behavior you can also act on a few additional information conveyed in\n  _snapshot_ attribute.\n\n  **Events:** _onDragStart_ and _onDragEnd_ functions will be triggered at the beginning and the end of re-ordering. They provide the necessary information as _TreePosition_\n   to change the tree.\n\n  **Current limitations = Plans:** Currently it's not possible to drag a parent, which is already expanded. Addition to this, it's not possible to hover over another item to\n  expand it or drop on top to nest. We are actively working on these features and we will update the documentation once they are ready.\n\n  **Example**\n\n  ", "\n\n  ", "\n"], ["\n  Tree component provides a generic way to visualize tree structures. It was built on top of the popular [react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd)\n  library in order to provide a natural way of reorganizing the nodes.\n\n  ## Feature set\n\n   - Fully customizable node rendering\n   - Capability to collapse and expand subtree\n   - Lazy loading of subtree\n   - Reorganization of the tree by drag&drop\n   - Mouse, touch and keyboard support\n\n  ## Usage\n\n  ", "\n\n  ",
    "\n\n  ## Get started\n\n  ### Tree data structure\n\n  Tree is defined by a normalized data structure, where _rootId_ defines the _id_ of the root node and _items_ map contains all the nodes indexed by their _id_.\n  Child relationship is defined in the _children_ field of parent in form of list of _id_'s.\n\n  **Data attribute:** Any consumer data should be defined in the _data_ attribute of item, e.g. title, color, selection etc.\n\n  **State handling:** This data structure is the single source of truth. After any interaction the consumer's responsibility to execute the mutation\n   on the tree, which will be passed down in props to refresh the rendered tree. A few utils functions (_mutateTree_, _moveItemOnTree_) are provided\n   in order to help you make those changes easily and in a efficient way.\n\n  **Performance / Side-effects:** We put some effort into optimizing rendering based on reference equality. We only re-render an Item if it's reference changed or\n  moved on the tree.\n\n  ",
    "\n\n  ### Rendering\n\n  In order to render the tree, _renderItem_ render prop must be defined on _Tree_. It will receive one object with multiple params, defined as _RenderItemParams_ .\n\n  **Root item** is not rendered by design. If you want to render a tree with a single root, you will need to create a virtual root above your effective root.\n\n  **Provided** is a concept inherited from react-beautiful-dnd library in order to provide flexible drag&drop functionality.\n\n   - _innerRef_ must be bound to the highest possible DOM node in the ReactElement. We do this in order to avoid needing to use ReactDOM to look up your DOM node.\n   - _draggableProps_ is an Object that contains a data attribute and an inline style. This Object needs to be applied to the same node that you apply provided.innerRef to. This controls the movement of the draggable when it is dragging and not dragging.\n   - _dragHandleProps_ is used to drag the whole tree item. Often this will be the highest level node, but sometimes it can be a child node. dragHandleProps need to be applied to the node that you want to be the drag handle.\n\n  ",
    "\n\n  **Example**\n\n  ",
    "\n\n  ### Expand & Collapse\n\n  _onExpand_ and _onCollapse_ functions are triggered when there is a need to change the state of a parent. This is the right time to trigger requests to load the subtree or\n  flip the _isExpanded_ attribute to show the already loaded children nodes.\n\n  **Example**\n\n  ",
    "\n\n  ### Drag & Drop\n\n  Drag&Drop is powered by [react-beautiful-dnd](https://github.com/atlassian/react-beautiful-dnd), so a couple of design principles are inherited from there. To make it work\n  _provided_ from _renderItem_ must be used as defined earlier in the Rendering section. For custom behavior you can also act on a few additional information conveyed in\n  _snapshot_ attribute.\n\n  **Events:** _onDragStart_ and _onDragEnd_ functions will be triggered at the beginning and the end of re-ordering. They provide the necessary information as _TreePosition_\n   to change the tree.\n\n  **Current limitations = Plans:** Currently it's not possible to drag a parent, which is already expanded. Addition to this, it's not possible to hover over another item to\n  expand it or drop on top to nest. We are actively working on these features and we will update the documentation once they are ready.\n\n  **Example**\n\n  ",
    "\n\n  ",
    "\n"])), docs_1.code(templateObject_1 || (templateObject_1 = __makeTemplateObject(["import Tree, { mutateTree, moveItemOnTree } from '@atlaskit/tree';"], ["import Tree, { mutateTree, moveItemOnTree } from '@atlaskit/tree';"]))), (<docs_1.Example packageName="@atlaskit/tree" Component={require('../examples/5-pure-tree')["default"]} title="Drag-n-Drop Tree" source={require('!!raw-loader!../examples/5-pure-tree')}/>), docs_1.code(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\ntype ItemId = any;\n\ninterface TreeData {\n  rootId: ItemId,\n  items: { [ItemId]: TreeItem },\n};\n\ntype TreeItem = {|\n  id: ItemId,\n  children: Array<ItemId>,\n  hasChildren?: boolean,\n  isExpanded?: boolean,\n  isChildrenLoading?: boolean,\n  data?: TreeItemData,\n|};\n  "], ["\ntype ItemId = any;\n\ninterface TreeData {\n  rootId: ItemId,\n  items: { [ItemId]: TreeItem },\n};\n\ntype TreeItem = {|\n  id: ItemId,\n  children: Array<ItemId>,\n  hasChildren?: boolean,\n  isExpanded?: boolean,\n  isChildrenLoading?: boolean,\n  data?: TreeItemData,\n|};\n  "]))), docs_1.code(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\ntype RenderItemParams = {|\n  /** Item to be rendered */\n  item: TreeItem,\n  /** The depth of the item on the tree. 0 means root level. */\n  depth: number,\n  /** Function to call when a parent item needs to be expanded */\n  onExpand: (itemId: ItemId) => void,\n  /** Function to call when a parent item needs to be collapsed */\n  onCollapse: (itemId: ItemId) => void,\n  /** Couple of Props to be spread into the rendered React.Components and DOM elements */\n  /** More info: https://github.com/atlassian/react-beautiful-dnd#children-function-render-props */\n  provided: TreeDraggableProvided,\n  /** Couple of state variables */\n  /** More info: https://github.com/atlassian/react-beautiful-dnd#2-snapshot-draggablestatesnapshot */\n  snapshot: DraggableStateSnapshot,\n|};\n  "], ["\ntype RenderItemParams = {|\n  /** Item to be rendered */\n  item: TreeItem,\n  /** The depth of the item on the tree. 0 means root level. */\n  depth: number,\n  /** Function to call when a parent item needs to be expanded */\n  onExpand: (itemId: ItemId) => void,\n  /** Function to call when a parent item needs to be collapsed */\n  onCollapse: (itemId: ItemId) => void,\n  /** Couple of Props to be spread into the rendered React.Components and DOM elements */\n  /** More info: https://github.com/atlassian/react-beautiful-dnd#children-function-render-props */\n  provided: TreeDraggableProvided,\n  /** Couple of state variables */\n  /** More info: https://github.com/atlassian/react-beautiful-dnd#2-snapshot-draggablestatesnapshot */\n  snapshot: DraggableStateSnapshot,\n|};\n  "]))), docs_1.code(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\nrenderItem = ({\n  item,\n  depth,\n  onExpand,\n  onCollapse,\n  provided,\n}: RenderItemParams) => {\n  return (\n    <div\n      ref={provided.innerRef}\n      {...provided.draggableProps}\n      {...provided.dragHandleProps}\n    >\n      <span>{getIcon(item, onExpand, onCollapse)}</span>\n      <span>{item.data ? item.data.title : ''}</span>\n    </div>\n  );\n};\n  "], ["\nrenderItem = ({\n  item,\n  depth,\n  onExpand,\n  onCollapse,\n  provided,\n}: RenderItemParams) => {\n  return (\n    <div\n      ref={provided.innerRef}\n      {...provided.draggableProps}\n      {...provided.dragHandleProps}\n    >\n      <span>{getIcon(item, onExpand, onCollapse)}</span>\n      <span>{item.data ? item.data.title : ''}</span>\n    </div>\n  );\n};\n  "]))), docs_1.code(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\nonExpand = (itemId: ItemId) => {\n  const { tree }: State = this.state;\n  this.setState({\n    tree: mutateTree(tree, itemId, { isExpanded: true }),\n  });\n};\n  "], ["\nonExpand = (itemId: ItemId) => {\n  const { tree }: State = this.state;\n  this.setState({\n    tree: mutateTree(tree, itemId, { isExpanded: true }),\n  });\n};\n  "]))), docs_1.code(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\ntype TreePosition = {|\n  parentId: ItemId,\n  index: number,\n|};\n\nonDragEnd = (source: TreePosition, destination: ?TreePosition) => {\n  const { tree } = this.state;\n\n  if (!destination) {\n    return;\n  }\n  const newTree = moveItemOnTree(tree, source, destination);\n  this.setState({\n    tree: newTree,\n  });\n};\n  "], ["\ntype TreePosition = {|\n  parentId: ItemId,\n  index: number,\n|};\n\nonDragEnd = (source: TreePosition, destination: ?TreePosition) => {\n  const { tree } = this.state;\n\n  if (!destination) {\n    return;\n  }\n  const newTree = moveItemOnTree(tree, source, destination);\n  this.setState({\n    tree: newTree,\n  });\n};\n  "]))), (<docs_1.Props title="API Reference" heading="Tree Props" props={require('!!extract-react-types-loader!../src/components/Tree/Tree')}/>));
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7;
